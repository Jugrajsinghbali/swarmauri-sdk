[
    {
        "document_name": "swarmauri/core/__init__.py",
        "content": "```swarmauri/core/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/ComponentBase.py",
        "content": "```swarmauri/core/ComponentBase.py\nfrom typing import (\n    Optional, \n    List,\n    Literal, \n    TypeVar, \n    Type, \n    Union, \n    Annotated, \n    Generic, \n    ClassVar, \n    Set,\n    get_args)\n\nfrom uuid import uuid4\nfrom enum import Enum\nimport inspect\nimport hashlib\nfrom pydantic import BaseModel, Field, field_validator\nimport logging\nfrom swarmauri.core.typing import SubclassUnion\n\nclass ResourceTypes(Enum):\n    UNIVERSAL_BASE = 'ComponentBase'\n    AGENT = 'Agent'\n    AGENT_FACTORY = 'AgentFactory'\n    CHAIN = 'Chain'\n    CHAIN_METHOD = 'ChainMethod'\n    CHUNKER = 'Chunker'\n    CONVERSATION = 'Conversation'\n    DISTANCE = 'Distance'\n    DOCUMENT_STORE = 'DocumentStore'\n    DOCUMENT = 'Document'\n    EMBEDDING = 'Embedding'\n    EXCEPTION = 'Exception'\n    LLM = 'LLM'\n    MESSAGE = 'Message'\n    METRIC = 'Metric'\n    PARSER = 'Parser'\n    PROMPT = 'Prompt'\n    STATE = 'State'\n    CHAINSTEP = 'ChainStep'\n    SCHEMA_CONVERTER = 'SchemaConverter'\n    SWARM = 'Swarm'\n    TOOLKIT = 'Toolkit'\n    TOOL = 'Tool'\n    PARAMETER = 'Parameter'\n    TRACE = 'Trace'\n    UTIL = 'Util'\n    VECTOR_STORE = 'VectorStore'\n    VECTOR = 'Vector'\n\ndef generate_id() -> str:\n    return str(uuid4())\n\nclass ComponentBase(BaseModel):\n    name: Optional[str] = None\n    id: str = Field(default_factory=generate_id)\n    members: List[str] = Field(default_factory=list)\n    owner: Optional[str] = None\n    host: Optional[str] = None\n    resource: str = Field(default=\"ComponentBase\")\n    version: str = \"0.1.0\"\n    __swm_subclasses__: ClassVar[Set[Type['ComponentBase']]] = set()\n    type: Literal['ComponentBase'] = 'ComponentBase'\n    \n\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        ComponentBase.__swm_register_subclass__(cls)\n    \n    # @classmethod\n    # def __swm__get_subclasses__(cls) -> set:\n    #     logging.debug('__swm__get_subclasses__ executed\\n')\n    #     def is_excluded_module(module_name: str) -> bool:\n    #         return (module_name == 'builtins' or \n    #                 module_name == 'types')\n\n    #     subclasses_dict = {cls.__name__: cls}\n    #     for subclass in cls.__subclasses__():\n    #         if not is_excluded_module(subclass.__module__):\n    #             subclasses_dict.update({_s.__name__: _s for _s in subclass.__swm__get_subclasses__() \n    #                 if not is_excluded_module(_s.__module__)})\n\n    #     return set(subclasses_dict.values())\n    \n    @classmethod\n    def __swm_register_subclass__(cls, subclass):\n        logging.debug('__swm_register_subclass__ executed\\n')\n        \n        if 'type' in subclass.__annotations__:\n            sub_type = subclass.__annotations__['type']\n            if sub_type not in [subclass.__annotations__['type'] for subclass in cls.__swm_subclasses__]:\n                cls.__swm_subclasses__.add(subclass)\n        else:\n            logging.warning(f'Subclass {subclass.__name__} does not have a type annotation')\n\n\n        # [subclass.__swm_reset_class__()  for subclass in cls.__swm_subclasses__ \n        #  if hasattr(subclass, '__swm_reset_class__')]\n    \n    \n    @classmethod\n    def __swm_reset_class__(cls):\n        logging.debug('__swm_reset_class__ executed\\n')\n        for each in cls.__fields__:\n            logging.debug(each, cls.__fields__[each].discriminator)\n            if (cls.__fields__[each].discriminator and each in cls.__annotations__\n               ):\n                if len(get_args(cls.__fields__[each].annotation)) > 0:\n                    for x in range(0, len(get_args(cls.__fields__[each].annotation))):\n                        if hasattr(get_args(cls.__fields__[each].annotation)[x], '__base__'):\n                            if (hasattr(get_args(cls.__fields__[each].annotation)[x].__base__, '__swm_subclasses__') and\n                            not get_args(cls.__fields__[each].annotation)[x].__base__.__name__ == 'ComponentBase'):\n\n                                baseclass = get_args(cls.__fields__[each].annotation)[x].__base__\n         \n                                sc = SubclassUnion[baseclass]\n                                \n                                cls.__annotations__[each] = sc\n                                cls.__fields__[each].annotation = sc\n\n        \n        # This is not necessary as the model_rebuild address forward_refs \n        # https://docs.pydantic.dev/latest/api/base_model/#pydantic.BaseModel.model_post_init\n        # cls.update_forward_refs() \n        cls.model_rebuild(force=True)\n\n\n    @field_validator('type')\n    def set_type(cls, v, values):\n        if v == 'ComponentBase' and cls.__name__ != 'ComponentBase':\n            return cls.__name__\n        return v\n\n    def __swm_class_hash__(self):\n        sig_hash = hashlib.sha256()\n        for attr_name in dir(self):\n            attr_value = getattr(self, attr_name)\n            if callable(attr_value) and not attr_name.startswith(\"_\"):\n                sig = inspect.signature(attr_value)\n                sig_hash.update(str(sig).encode())\n        return sig_hash.hexdigest()\n\n    @classmethod\n    def swm_public_interfaces(cls):\n        methods = []\n        for attr_name in dir(cls):\n            attr_value = getattr(cls, attr_name)\n            if (callable(attr_value) and not attr_name.startswith(\"_\")) or isinstance(attr_value, property):\n                methods.append(attr_name)\n        return methods\n\n    @classmethod\n    def swm_ismethod_registered(cls, method_name: str):\n        return method_name in cls.public_interfaces()\n\n    @classmethod\n    def swm_method_signature(cls, input_signature):\n        for method_name in cls.public_interfaces():\n            method = getattr(cls, method_name)\n            if callable(method):\n                sig = str(inspect.signature(method))\n                if sig == input_signature:\n                    return True\n        return False\n\n    @property\n    def swm_path(self):\n        if self.host and self.owner:\n            return f\"{self.host}/{self.owner}/{self.resource}/{self.name}/{self.id}\"\n        if self.resource and self.name:\n            return f\"/{self.resource}/{self.name}/{self.id}\"\n        return f\"/{self.resource}/{self.id}\"\n\n    @property\n    def swm_isremote(self):\n        return bool(self.host)\n```"
    },
    {
        "document_name": "swarmauri/core/typing.py",
        "content": "```swarmauri/core/typing.py\nimport logging\nfrom pydantic import BaseModel, Field\nfrom typing import TypeVar, Generic, Union, Annotated, Type\n\n\nclass SubclassUnion:\n\n    @classmethod\n    def __class_getitem__(cls, baseclass):\n        subclasses = cls.__swm__get_subclasses__(baseclass)\n        return Union[tuple(subclasses)]\n\n    @classmethod\n    def __swm__get_subclasses__(cls, baseclass) -> set:\n        logging.debug('__swm__get_subclasses__ executed\\n')\n        def is_excluded_module(module_name: str) -> bool:\n            return (module_name == 'builtins' or \n                    module_name == 'types')\n\n        subclasses_dict = {baseclass.__name__: baseclass}\n        for subclass in baseclass.__subclasses__():\n            if not is_excluded_module(subclass.__module__):\n                subclasses_dict.update({_s.__name__: _s for _s in cls.__swm__get_subclasses__(subclass) \n                    if not is_excluded_module(_s.__module__)})\n\n        return set(subclasses_dict.values())\n```"
    },
    {
        "document_name": "swarmauri/core/llms/IFit.py",
        "content": "```swarmauri/core/llms/IFit.py\nfrom abc import ABC, abstractmethod\n\nclass IFit(ABC):\n    \"\"\"\n    Interface for training models.\n    \"\"\"\n\n    @abstractmethod\n    def fit(self, X_train, y_train, epochs: int, batch_size: int) -> None:\n        \"\"\"\n        Train the model on the provided dataset.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/llms/IPredict.py",
        "content": "```swarmauri/core/llms/IPredict.py\nfrom abc import ABC, abstractmethod\n\nclass IPredict(ABC):\n    \"\"\"\n    Interface focusing on the basic properties and settings essential for defining models.\n    \"\"\"\n\n    @abstractmethod\n    def predict(self, *args, **kwargs) -> any:\n        \"\"\"\n        Generate predictions based on the input data provided to the model.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/llms/__init__.py",
        "content": "```swarmauri/core/llms/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/agent_apis/__init__.py",
        "content": "```swarmauri/core/agent_apis/__init__.py\nfrom .IAgentCommands import IAgentCommands\nfrom .IAgentRouterCRUD import IAgentRouterCRUD\n\n__all__ = ['IAgentCommands', 'IAgentRouterCRUD']\n```"
    },
    {
        "document_name": "swarmauri/core/agent_apis/IAgentRouterCRUD.py",
        "content": "```swarmauri/core/agent_apis/IAgentRouterCRUD.py\nfrom abc import ABC, abstractmethod\nfrom typing import Callable, Any, Dict\n\nclass IAgentRouterCRUD(ABC):\n    \"\"\"\n    Interface for managing API routes within a SwarmAgent.\n    \"\"\"\n    \n    @abstractmethod\n    def create_route(self, path: str, method: str, handler: Callable[[Any], Any]) -> None:\n        \"\"\"\n        Create a new route for the API.\n        \n        Parameters:\n        - path (str): The URL path for the route.\n        - method (str): The HTTP method (e.g., 'GET', 'POST').\n        - handler (Callable[[Any], Any]): The function that handles requests to this route.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def read_route(self, path: str, method: str) -> Dict:\n        \"\"\"\n        Retrieve information about a specific route.\n        \n        Parameters:\n        - path (str): The URL path for the route.\n        - method (str): The HTTP method.\n        \n        Returns:\n        - Dict: Information about the route, including path, method, and handler.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def update_route(self, path: str, method: str, new_handler: Callable[[Any], Any]) -> None:\n        \"\"\"\n        Update the handler function for an existing route.\n        \n        Parameters:\n        - path (str): The URL path for the route.\n        - method (str): The HTTP method.\n        - new_handler (Callable[[Any], Any]): The new function that handles requests to this route.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def delete_route(self, path: str, method: str) -> None:\n        \"\"\"\n        Delete a specific route from the API.\n        \n        Parameters:\n        - path (str): The URL path for the route.\n        - method (str): The HTTP method.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/agent_apis/IAgentCommands.py",
        "content": "```swarmauri/core/agent_apis/IAgentCommands.py\nfrom abc import ABC, abstractmethod\nfrom typing import Callable, Any, List\n\nclass IAgentCommands(ABC):\n    \"\"\"\n    Interface for the API object that enables a SwarmAgent to host various API routes.\n    \"\"\"\n\n\n    @abstractmethod\n    def invoke(self, request: Any) -> Any:\n        \"\"\"\n        Handles invocation requests synchronously.\n        \n        Parameters:\n            request (Any): The incoming request payload.\n\n        Returns:\n            Any: The response payload.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def ainvoke(self, request: Any) -> Any:\n        \"\"\"\n        Handles invocation requests asynchronously.\n        \n        Parameters:\n            request (Any): The incoming request payload.\n\n        Returns:\n            Any: The response payload.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def batch(self, requests: List[Any]) -> List[Any]:\n        \"\"\"\n        Handles batched invocation requests synchronously.\n        \n        Parameters:\n            requests (List[Any]): A list of incoming request payloads.\n\n        Returns:\n            List[Any]: A list of responses.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def abatch(self, requests: List[Any]) -> List[Any]:\n        \"\"\"\n        Handles batched invocation requests asynchronously.\n\n        Parameters:\n            requests (List[Any]): A list of incoming request payloads.\n\n        Returns:\n            List[Any]: A list of responses.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def stream(self, request: Any) -> Any:\n        \"\"\"\n        Handles streaming requests.\n\n        Parameters:\n            request (Any): The incoming request payload.\n\n        Returns:\n            Any: A streaming response.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_schema_config(self) -> dict:\n        \"\"\"\n        Retrieves the schema configuration for the API.\n\n        Returns:\n            dict: The schema configuration.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/conversations/__init__.py",
        "content": "```swarmauri/core/conversations/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/conversations/IMaxSize.py",
        "content": "```swarmauri/core/conversations/IMaxSize.py\nfrom abc import ABC, abstractmethod\n\nclass IMaxSize(ABC):\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/conversations/ISystemContext.py",
        "content": "```swarmauri/core/conversations/ISystemContext.py\nfrom abc import ABC, abstractmethod\n\nclass ISystemContext(ABC):\n    pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/conversations/IConversation.py",
        "content": "```swarmauri/core/conversations/IConversation.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom swarmauri.core.messages.IMessage import IMessage\n\n\nclass IConversation(ABC):\n    \"\"\"\n    Interface for managing conversations, defining abstract methods for\n    adding messages, retrieving the latest message, getting all messages, and clearing history.\n    \"\"\"\n\n    @property\n    def history(self) -> List[IMessage]:\n        \"\"\"\n        Provides read-only access to the conversation history.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_message(self, message: IMessage):\n        \"\"\"\n        Adds a message to the conversation history.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_messages(self, messages: List[IMessage]):\n        \"\"\"\n        Adds multiple messages to the conversation history.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_last(self) -> Optional[IMessage]:\n        \"\"\"\n        Retrieves the latest message from the conversation history.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def clear_history(self) -> None:\n        \"\"\"\n        Clears the conversation history.\n        \"\"\"\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/documents/__init__.py",
        "content": "```swarmauri/core/documents/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/documents/IExperimentDocument.py",
        "content": "```swarmauri/core/documents/IExperimentDocument.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom swarmauri.core.documents.IDocument import IDocument\n\nclass IExperimentDocument(IDocument, ABC):\n    \"\"\"\n    Interface for an Experiment Document, extending the general IDocument interface\n    with additional properties and methods specific to experimental data.\n    \"\"\"\n    @property\n    @abstractmethod\n    def parameters(self) -> Dict[str, Any]:\n        \"\"\"\n        Get the parameters used in the experiment.\n        \"\"\"\n        pass\n\n    @parameters.setter\n    @abstractmethod\n    def parameters(self, value: Dict[str, Any]) -> None:\n        \"\"\"\n        Set the parameters used in the experiment.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def results(self) -> Dict[str, Any]:\n        \"\"\"\n        Get the results obtained from the experiment.\n        \"\"\"\n        pass\n\n    @results.setter\n    @abstractmethod\n    def results(self, value: Dict[str, Any]) -> None:\n        \"\"\"\n        Set the results obtained from the experiment.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def instruction(self) -> str:\n        \"\"\"\n        An instructional or descriptive text about what the experiment aims to achieve or how.\n        \"\"\"\n        pass\n\n    @instruction.setter\n    @abstractmethod\n    def instruction(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def feature_set(self) -> List[Any]:\n        \"\"\"\n        Description of the set of features or data used in the experiment.\n        \"\"\"\n        pass\n\n    @feature_set.setter\n    @abstractmethod\n    def feature_set(self, value: List[Any]) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def version(self) -> str:\n        \"\"\"\n        The version of the experiment, useful for tracking iterations and changes over time.\n        \"\"\"\n        pass\n\n    @version.setter\n    @abstractmethod\n    def version(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def artifacts(self) -> List[str]:\n        \"\"\"\n        A list of paths or identifiers for any artifacts generated by the experiment,\n        such as models, charts, or data dumps.\n        \"\"\"\n        pass\n\n    @artifacts.setter\n    @abstractmethod\n    def artifacts(self, value: List[str]) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def datetime_created(self) -> datetime:\n        \"\"\"\n        Timestamp marking when the experiment was initiated or created.\n        \"\"\"\n        pass\n\n    @datetime_created.setter\n    @abstractmethod\n    def datetime_created(self, value: datetime) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def datetime_completed(self) -> Optional[datetime]:\n        \"\"\"\n        Timestamp of when the experiment was completed. None if the experiment is still running.\n        \"\"\"\n        pass\n\n    @datetime_completed.setter\n    @abstractmethod\n    def datetime_completed(self, value: Optional[datetime]) -> None:\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/documents/IDocument.py",
        "content": "```swarmauri/core/documents/IDocument.py\nfrom abc import ABC\n\nclass IDocument(ABC):\n   pass\n```"
    },
    {
        "document_name": "swarmauri/core/messages/__init__.py",
        "content": "```swarmauri/core/messages/__init__.py\nfrom .IMessage import IMessage\n```"
    },
    {
        "document_name": "swarmauri/core/messages/IMessage.py",
        "content": "```swarmauri/core/messages/IMessage.py\nfrom abc import ABC, abstractmethod\n\nclass IMessage(ABC):\n    \"\"\"\n    An abstract interface representing a general message structure.\n\n    This interface defines the basic attributes that all\n    messages should have, including type, name, and content, \n    and requires subclasses to implement representation and formatting methods.\n    \"\"\"\n\n```"
    },
    {
        "document_name": "swarmauri/core/parsers/__init__.py",
        "content": "```swarmauri/core/parsers/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/parsers/IParser.py",
        "content": "```swarmauri/core/parsers/IParser.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union, Any\nfrom swarmauri.core.documents.IDocument import IDocument\n\nclass IParser(ABC):\n    \"\"\"\n    Abstract base class for parsers. It defines a public method to parse input data (str or Message) into documents,\n    and relies on subclasses to implement the specific parsing logic through protected and private methods.\n    \"\"\"\n\n    @abstractmethod\n    def parse(self, data: Union[str, Any]) -> List[IDocument]:\n        \"\"\"\n        Public method to parse input data (either a str or a Message) into a list of Document instances.\n        \n        This method leverages the abstract _parse_data method which must be\n        implemented by subclasses to define specific parsing logic.\n        \"\"\"\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/prompts/__init__.py",
        "content": "```swarmauri/core/prompts/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/prompts/IPrompt.py",
        "content": "```swarmauri/core/prompts/IPrompt.py\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Any\n\nclass IPrompt(ABC):\n    \"\"\"\n    A base abstract class representing a prompt system.\n\n    Methods:\n        __call__: Abstract method that subclasses must implement to enable the instance to be called directly.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self, **kwargs) -> str:\n        \"\"\"\n        Abstract method that subclasses must implement to define the behavior of the prompt when called.\n\n        \"\"\"\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/prompts/IPromptMatrix.py",
        "content": "```swarmauri/core/prompts/IPromptMatrix.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Tuple, Optional, Any\n\nclass IPromptMatrix(ABC):\n\n    @property\n    @abstractmethod\n    def shape(self) -> Tuple[int, int]:\n        \"\"\"Get the shape (number of agents, sequence length) of the prompt matrix.\"\"\"\n        pass\n\n    @abstractmethod\n    def add_prompt_sequence(self, sequence: List[Optional[str]]) -> None:\n        \"\"\"Add a new prompt sequence to the matrix.\"\"\"\n        pass\n\n    @abstractmethod\n    def remove_prompt_sequence(self, index: int) -> None:\n        \"\"\"Remove a prompt sequence from the matrix by index.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_prompt_sequence(self, index: int) -> List[Optional[str]]:\n        \"\"\"Get a prompt sequence from the matrix by index.\"\"\"\n        pass\n\n    @abstractmethod\n    def show(self) -> List[List[Optional[str]]]:\n        \"\"\"Show the entire prompt matrix.\"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/prompts/ITemplate.py",
        "content": "```swarmauri/core/prompts/ITemplate.py\nfrom typing import Dict, List, Any, Union\nfrom abc import ABC, abstractmethod\n\n\nclass ITemplate(ABC):\n    \"\"\"\n    Interface for template-based prompt generation within the SwarmAURI framework.\n    Defines standard operations and attributes for managing and utilizing templates.\n    \"\"\"\n    \n    @abstractmethod\n    def set_template(self, template: str) -> None:\n        \"\"\"\n        Sets or updates the current template string.\n\n        Args:\n            template (str): The new template string to be used for generating prompts.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_variables(self, \n                      variables: Union[List[Dict[str, Any]], Dict[str, Any]] = {}) -> None:\n        \"\"\"\n        Sets or updates the variables to be substituted into the template.\n\n        Args:\n            variables (List[Dict[str, str]]): A dictionary of variables where each key-value \n                                        pair corresponds to a placeholder name and its \n                                        replacement value in the template.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def generate_prompt(self, **kwargs) -> str:\n        \"\"\"\n        Generates a prompt string based on the current template and provided keyword arguments.\n\n        Args:\n            **kwargs: Keyword arguments containing variables for template substitution. \n\n        Returns:\n            str: The generated prompt string with template variables replaced by their\n                 corresponding values provided in `kwargs`.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/agents/__init__.py",
        "content": "```swarmauri/core/agents/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/agents/IAgentParser.py",
        "content": "```swarmauri/core/agents/IAgentParser.py\nfrom abc import ABC, abstractmethod\nfrom swarmauri.core.parsers.IParser import IParser \n\nclass IAgentParser(ABC):\n    \n    @property\n    @abstractmethod\n    def parser(self) -> IParser:\n        pass\n\n    @parser.setter\n    @abstractmethod\n    def parser(self) -> IParser:\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/agents/IAgent.py",
        "content": "```swarmauri/core/agents/IAgent.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Optional, Dict\n\nclass IAgent(ABC):\n\n    @abstractmethod\n    def exec(self, input_data: Optional[Any], llm_kwargs: Optional[Dict]) -> Any:\n        \"\"\"\n        Executive method that triggers the agent's action based on the input data.\n        \"\"\"\n        pass\n    \n```"
    },
    {
        "document_name": "swarmauri/core/agents/IAgentConversation.py",
        "content": "```swarmauri/core/agents/IAgentConversation.py\nfrom abc import ABC, abstractmethod\nfrom swarmauri.core.conversations.IConversation import IConversation\n\nclass IAgentConversation(ABC):\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/agents/IAgentRetrieve.py",
        "content": "```swarmauri/core/agents/IAgentRetrieve.py\nfrom abc import ABC\n\nclass IAgentRetrieve(ABC):\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/agents/IAgentSystemContext.py",
        "content": "```swarmauri/core/agents/IAgentSystemContext.py\nfrom abc import ABC, abstractmethod\n\nclass IAgentSystemContext(ABC):\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/agents/IAgentToolkit.py",
        "content": "```swarmauri/core/agents/IAgentToolkit.py\nfrom abc import ABC\n\nclass IAgentToolkit(ABC):\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/agents/IAgentVectorStore.py",
        "content": "```swarmauri/core/agents/IAgentVectorStore.py\nfrom abc import ABC\n\nclass IAgentVectorStore(ABC):\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/swarms/__init__.py",
        "content": "```swarmauri/core/swarms/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/swarms/ISwarm.py",
        "content": "```swarmauri/core/swarms/ISwarm.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List, Dict\nfrom datetime import datetime\nfrom swarmauri.core.agents.IAgent import IAgent\nfrom swarmauri.core.chains.ICallableChain import ICallableChain\n\nclass ISwarm(ABC):\n    \"\"\"\n    Interface for a Swarm, representing a collective of agents capable of performing tasks, executing callable chains, and adaptable configurations.\n    \"\"\"\n\n    # Abstract properties and setters\n    @property\n    @abstractmethod\n    def id(self) -> str:\n        \"\"\"Unique identifier for the factory instance.\"\"\"\n        pass\n\n    @id.setter\n    @abstractmethod\n    def id(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        pass\n\n    @name.setter\n    @abstractmethod\n    def name(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def type(self) -> str:\n        pass\n\n    @type.setter\n    @abstractmethod\n    def type(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def date_created(self) -> datetime:\n        pass\n\n    @property\n    @abstractmethod\n    def last_modified(self) -> datetime:\n        pass\n\n    @last_modified.setter\n    @abstractmethod\n    def last_modified(self, value: datetime) -> None:\n        pass\n\n    def __hash__(self):\n        \"\"\"\n        The __hash__ method allows objects of this class to be used in sets and as dictionary keys.\n        __hash__ should return an integer and be defined based on immutable properties.\n        This is generally implemented directly in concrete classes rather than in the interface,\n        but it's declared here to indicate that implementing classes must provide it.\n        \"\"\"\n        pass\n\n\n```"
    },
    {
        "document_name": "swarmauri/core/swarms/ISwarmComponent.py",
        "content": "```swarmauri/core/swarms/ISwarmComponent.py\nfrom abc import ABC, abstractmethod\n\nclass ISwarmComponent(ABC):\n    \"\"\"\n    Interface for defining a general component within a swarm system.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self, key: str, name: str):\n        \"\"\"\n        Initializes a swarm component with a unique key and name.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/swarms/ISwarmConfigurationExporter.py",
        "content": "```swarmauri/core/swarms/ISwarmConfigurationExporter.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict\nclass ISwarmConfigurationExporter(ABC):\n\n    @abstractmethod\n    def to_dict(self) -> Dict:\n        \"\"\"\n        Serializes the swarm configuration to a dictionary.\n\n        Returns:\n            Dict: The serialized configuration as a dictionary.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_json(self) -> str:\n        \"\"\"\n        Serializes the swarm configuration to a JSON string.\n\n        Returns:\n            str: The serialized configuration as a JSON string.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_pickle(self) -> bytes:\n        \"\"\"\n        Serializes the swarm configuration to a Pickle byte stream.\n\n        Returns:\n            bytes: The serialized configuration as a Pickle byte stream.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/swarms/ISwarmFactory.py",
        "content": "```swarmauri/core/swarms/ISwarmFactory.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Callable, Dict, List, NamedTuple, Optional, Type, Union\nfrom swarmauri.core.swarms.ISwarm import ISwarm\nfrom swarmauri.core.chains.ICallableChain import ICallableChain \nfrom swarmauri.core.agents.IAgent import IAgent \n\nclass Step(NamedTuple):\n    description: str\n    callable: Callable  # Reference to the function to execute\n    args: Optional[List[Any]] = None\n    kwargs: Optional[Dict[str, Any]] = None\n\nclass CallableChainItem(NamedTuple):\n    key: str  # Unique identifier for the item within the chain\n    execution_context: Dict[str, Any]  # Execution context and metadata\n    steps: List[Step]\n\nclass AgentDefinition(NamedTuple):\n    type: str\n    configuration: Dict[str, Any]\n    capabilities: List[str]\n    dependencies: List[str]\n    execution_context: Dict[str, Any]\n\nclass FunctionParameter(NamedTuple):\n    name: str\n    type: Type\n    default: Optional[Any] = None\n    required: bool = True\n\nclass FunctionDefinition(NamedTuple):\n    identifier: str\n    parameters: List[FunctionParameter]\n    return_type: Type\n    execution_context: Dict[str, Any]\n    callable_source: Callable\n    \nclass ISwarmFactory(ABC):\n\n    @abstractmethod\n    def create_swarm(self, *args, **kwargs) -> ISwarm:\n        \"\"\"\n        Creates and returns a new swarm instance configured with the provided arguments.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def create_agent(self, agent_definition: AgentDefinition) -> IAgent:\n        \"\"\"\n        Creates a new agent based on the provided enhanced agent definition.\n        \n        Args:\n            agent_definition: An instance of AgentDefinition detailing the agent's setup.\n        \n        Returns:\n            An instance or identifier of the newly created agent.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def create_callable_chain(self, chain_definition: List[CallableChainItem]) -> ICallableChain:\n        \"\"\"\n        Creates a new callable chain based on the provided definition.\n\n        Args:\n            chain_definition: Details required to build the chain, such as sequence of functions and arguments.\n\n        Returns:\n            ICallableChain: The constructed callable chain instance.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def register_function(self, function_definition: FunctionDefinition) -> None:\n        \"\"\"\n        Registers a function within the factory ecosystem, making it available for callable chains and agents.\n\n        Args:\n            function_definition: An instance of FunctionDefinition detailing the function's specification.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def export_callable_chains(self, format_type: str = 'json') -> Union[dict, str, bytes]:\n        \"\"\"\n        Exports configurations of all callable chains in the specified format.\n        Supported formats: 'json', 'pickle'.\n\n        Args:\n            format_type (str): The format for exporting the configurations.\n\n        Returns:\n            Union[dict, str, bytes]: The callable chain configurations in the specified format.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def load_callable_chains(self, chains_data, format_type: str = 'json'):\n        \"\"\"\n        Loads callable chain configurations from given data.\n\n        Args:\n            chains_data (Union[dict, str, bytes]): Data containing callable chain configurations.\n            format_type (str): The format of the provided chains data.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def export_configuration(self, format_type: str = 'json') -> Union[dict, str, bytes]:\n        \"\"\"\n        Exports the swarm's and agents' configurations in the specified format.\n        Supported formats: 'json', 'pickle'. Default is 'json'.\n\n        Args:\n            format_type (str): The format for exporting the configurations.\n\n        Returns:\n            Union[dict, str, bytes]: The configurations in the specified format.\n        \"\"\"\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/swarms/ISwarmAgentRegistration.py",
        "content": "```swarmauri/core/swarms/ISwarmAgentRegistration.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Optional\nfrom swarmauri.core.agents.IAgent import IAgent\n\nclass ISwarmAgentRegistration(ABC):\n    \"\"\"\n    Interface for registering agents with the swarm, designed to support CRUD operations on IAgent instances.\n    \"\"\"\n\n    @id.setter\n    @abstractmethod\n    def registry(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def registry(self) -> List[IAgent]:\n        pass\n\n    @abstractmethod\n    def register_agent(self, agent: IAgent) -> bool:\n        \"\"\"\n        Register a new agent with the swarm.\n\n        Parameters:\n            agent (IAgent): An instance of IAgent representing the agent to register.\n\n        Returns:\n            bool: True if the registration succeeded; False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_agent(self, agent_id: str, updated_agent: IAgent) -> bool:\n        \"\"\"\n        Update the details of an existing agent. This could include changing the agent's configuration,\n        task assignment, or any other mutable attribute.\n\n        Parameters:\n            agent_id (str): The unique identifier for the agent.\n            updated_agent (IAgent): An updated IAgent instance to replace the existing one.\n\n        Returns:\n            bool: True if the update was successful; False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_agent(self, agent_id: str) -> bool:\n        \"\"\"\n        Remove an agent from the swarm based on its unique identifier.\n\n        Parameters:\n            agent_id (str): The unique identifier for the agent to be removed.\n\n        Returns:\n            bool: True if the removal was successful; False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_agent(self, agent_id: str) -> Optional[IAgent]:\n        \"\"\"\n        Retrieve an agent's instance from its unique identifier.\n\n        Parameters:\n            agent_id (str): The unique identifier for the agent of interest.\n\n        Returns:\n            Optional[IAgent]: The IAgent instance if found; None otherwise.\n        \"\"\"\n        pass\n\n\n```"
    },
    {
        "document_name": "swarmauri/core/swarms/ISwarmChainCRUD.py",
        "content": "```swarmauri/core/swarms/ISwarmChainCRUD.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any\n\nclass ISwarmChainCRUD(ABC):\n    \"\"\"\n    Interface to provide CRUD operations for ICallableChain within swarms.\n    \"\"\"\n\n    @abstractmethod\n    def create_chain(self, chain_id: str, chain_definition: Dict[str, Any]) -> None:\n        \"\"\"\n        Creates a callable chain with the provided definition.\n\n        Parameters:\n        - chain_id (str): A unique identifier for the callable chain.\n        - chain_definition (Dict[str, Any]): The definition of the callable chain including steps and their configurations.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def read_chain(self, chain_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Retrieves the definition of a callable chain by its identifier.\n\n        Parameters:\n        - chain_id (str): The unique identifier of the callable chain to be retrieved.\n\n        Returns:\n        - Dict[str, Any]: The definition of the callable chain.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_chain(self, chain_id: str, new_definition: Dict[str, Any]) -> None:\n        \"\"\"\n        Updates an existing callable chain with a new definition.\n\n        Parameters:\n        - chain_id (str): The unique identifier of the callable chain to be updated.\n        - new_definition (Dict[str, Any]): The new definition of the callable chain including updated steps and configurations.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_chain(self, chain_id: str) -> None:\n        \"\"\"\n        Removes a callable chain from the swarm.\n\n        Parameters:\n        - chain_id (str): The unique identifier of the callable chain to be removed.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def list_chains(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Lists all callable chains currently managed by the swarm.\n\n        Returns:\n        - List[Dict[str, Any]]: A list of callable chain definitions.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/toolkits/__init__.py",
        "content": "```swarmauri/core/toolkits/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/toolkits/IToolkit.py",
        "content": "```swarmauri/core/toolkits/IToolkit.py\nfrom typing import Dict\nfrom abc import ABC, abstractmethod\nfrom swarmauri.core.tools.ITool import ITool\n\nclass IToolkit(ABC):\n    \"\"\"\n    A class representing a toolkit used by Swarm Agents.\n    Tools are maintained in a dictionary keyed by the tool's name.\n    \"\"\"\n\n    @abstractmethod\n    def add_tools(self, tools: Dict[str, ITool]):\n        \"\"\"\n        An abstract method that should be implemented by subclasses to add multiple tools to the toolkit.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_tool(self, tool: ITool):\n        \"\"\"\n        An abstract method that should be implemented by subclasses to add a single tool to the toolkit.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_tool(self, tool_name: str):\n        \"\"\"\n        An abstract method that should be implemented by subclasses to remove a tool from the toolkit by name.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_tool_by_name(self, tool_name: str) -> ITool:\n        \"\"\"\n        An abstract method that should be implemented by subclasses to retrieve a tool from the toolkit by name.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def __len__(self) -> int:\n        \"\"\"\n        An abstract method that should be implemented by subclasses to return the number of tools in the toolkit.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/tools/__init__.py",
        "content": "```swarmauri/core/tools/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/tools/IParameter.py",
        "content": "```swarmauri/core/tools/IParameter.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union\n\nclass IParameter(ABC):\n    \"\"\"\n    An abstract class to represent a parameter for a tool.\n    \"\"\"\n\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/tools/ITool.py",
        "content": "```swarmauri/core/tools/ITool.py\nfrom abc import ABC, abstractmethod\n\nclass ITool(ABC):\n        \n    @abstractmethod\n    def call(self, *args, **kwargs):\n        pass\n    \n    @abstractmethod\n    def __call__(self, *args, **kwargs):\n        pass\n\n\n```"
    },
    {
        "document_name": "swarmauri/core/utils/__init__.py",
        "content": "```swarmauri/core/utils/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/utils/ITransactional.py",
        "content": "```swarmauri/core/utils/ITransactional.py\nfrom abc import ABC, abstractmethod\n\nclass ITransactional(ABC):\n\n    @abstractmethod\n    def begin_transaction(self):\n        \"\"\"\n        Initiates a transaction for a series of vector store operations.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def commit_transaction(self):\n        \"\"\"\n        Commits the current transaction, making all operations within the transaction permanent.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def abort_transaction(self):\n        \"\"\"\n        Aborts the current transaction, reverting all operations performed within the transaction.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/ISimiliarityQuery.py",
        "content": "```swarmauri/core/vector_stores/ISimiliarityQuery.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict\n\nclass ISimilarityQuery(ABC):\n    \n    @abstractmethod\n    def search_by_similarity_threshold(self, query_vector: List[float], similarity_threshold: float, space_name: str = None) -> List[Dict]:\n        \"\"\"\n        Search vectors exceeding a similarity threshold to a query vector within an optional vector space.\n\n        Args:\n            query_vector (List[float]): The high-dimensional query vector.\n            similarity_threshold (float): The similarity threshold for filtering results.\n            space_name (str, optional): The name of the vector space to search within.\n\n        Returns:\n            List[Dict]: A list of dictionaries with vector IDs, similarity scores, and optional metadata that meet the similarity threshold.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IGradient.py",
        "content": "```swarmauri/core/vector_stores/IGradient.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Callable\n\nclass IGradient(ABC):\n    \"\"\"\n    Interface for calculating the gradient of a scalar field.\n    \"\"\"\n\n    @abstractmethod\n    def calculate_gradient(self, scalar_field: Callable[[List[float]], float], point: List[float]) -> List[float]:\n        \"\"\"\n        Calculate the gradient of a scalar field at a specific point.\n\n        Parameters:\n        - scalar_field (Callable[[List[float]], float]): The scalar field represented as a function\n                                                         that takes a point and returns a scalar value.\n        - point (List[float]): The point at which the gradient is to be calculated.\n\n        Returns:\n        - List[float]: The gradient vector at the specified point.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IAngleBetweenVectors.py",
        "content": "```swarmauri/core/vector_stores/IAngleBetweenVectors.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass IAngleBetweenVectors(ABC):\n    \"\"\"\n    Interface for calculating the angle between two vectors.\n    \"\"\"\n\n    @abstractmethod\n    def angle_between(self, vector_a: List[float], vector_b: List[float]) -> float:\n        \"\"\"\n        Method to calculate and return the angle in radians between two vectors.\n\n        Parameters:\n        - vector_a (List[float]): The first vector as a list of floats.\n        - vector_b (List[float]): The second vector as a list of floats.\n\n        Returns:\n        - float: The angle between vector_a and vector_b in radians.\n\n        Note: Implementations should handle the vectors' dimensionality and throw appropriate exceptions for incompatible vectors.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IDecompose.py",
        "content": "```swarmauri/core/vector_stores/IDecompose.py\nfrom abc import ABC, abstractmethod\nfrom typing import Tuple, List\nfrom swarmauri.core.vectors.IVector import IVector  # Assuming there's a base IVector interface for vector representations\n\nclass IDecompose(ABC):\n    \"\"\"\n    Interface for decomposing a vector into components along specified basis vectors.\n    This operation is essential in expressing a vector in different coordinate systems or reference frames.\n    \"\"\"\n\n    @abstractmethod\n    def decompose(self, vector: IVector, basis_vectors: List[IVector]) -> List[IVector]:\n        \"\"\"\n        Decompose the given vector into components along the specified basis vectors.\n\n        Parameters:\n        - vector (IVector): The vector to be decomposed.\n        - basis_vectors (List[IVector]): A list of basis vectors along which to decompose the given vector.\n\n        Returns:\n        - List[IVector]: A list of vectors, each representing the component of the decomposed vector along \n                         the corresponding basis vector in the `basis_vectors` list.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IDivergence.py",
        "content": "```swarmauri/core/vector_stores/IDivergence.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass IDivergence(ABC):\n    \"\"\"\n    Interface for calculating the divergence of a vector field.\n    \"\"\"\n\n    @abstractmethod\n    def calculate_divergence(self, vector_field: List[List[float]], point: List[float]) -> float:\n        \"\"\"\n        Calculate the divergence of a vector field at a specific point.\n\n        Parameters:\n        - vector_field (List[List[float]]): A representation of the vector field as a list of vectors.\n        - point (List[float]): The point at which the divergence is to be calculated.\n\n        Returns:\n        - float: The divergence value at the specified point.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IOrthogonalProject.py",
        "content": "```swarmauri/core/vector_stores/IOrthogonalProject.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass IOrthogonalProject(ABC):\n    \"\"\"\n    Interface for calculating the orthogonal projection of one vector onto another.\n    \"\"\"\n\n    @abstractmethod\n    def orthogonal_project(self, vector_a: List[float], vector_b: List[float]) -> List[float]:\n        \"\"\"\n        Calculates the orthogonal projection of vector_a onto vector_b.\n        \n        Args:\n            vector_a (List[float]): The vector to be projected.\n            vector_b (List[float]): The vector onto which vector_a is orthogonally projected.\n        \n        Returns:\n            List[float]: The orthogonal projection of vector_a onto vector_b.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IProject.py",
        "content": "```swarmauri/core/vector_stores/IProject.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass IProject(ABC):\n    \"\"\"\n    Interface for projecting one vector onto another.\n    \"\"\"\n\n    @abstractmethod\n    def project(self, vector_a: List[float], vector_b: List[float]) -> List[float]:\n        \"\"\"\n        Projects vector_a onto vector_b.\n        \n        Args:\n            vector_a (List[float]): The vector to be projected.\n            vector_b (List[float]): The vector onto which vector_a is projected.\n        \n        Returns:\n            List[float]: The projection of vector_a onto vector_b.\n        \"\"\"\n        pass\n\n\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IReflect.py",
        "content": "```swarmauri/core/vector_stores/IReflect.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass IReflect(ABC):\n    \"\"\"\n    Interface for reflecting a vector across a specified plane or axis.\n    \"\"\"\n\n    @abstractmethod\n    def reflect_vector(self, vector: List[float], normal: List[float]) -> List[float]:\n        \"\"\"\n        Reflects a vector across a plane or axis defined by a normal vector.\n\n        Parameters:\n        - vector (List[float]): The vector to be reflected.\n        - normal (List[float]): The normal vector of the plane across which the vector will be reflected.\n\n        Returns:\n        - List[float]: The reflected vector.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/ISimilarity.py",
        "content": "```swarmauri/core/vector_stores/ISimilarity.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Tuple\nfrom swarmauri.core.vectors.IVector import IVector\n\nclass ISimilarity(ABC):\n    \"\"\"\n    Interface to define operations for computing similarity and distance between vectors.\n    This interface is crucial for systems that need to perform similarity searches, clustering,\n    or any operations where vector similarity plays a key role.\n    \"\"\"\n\n    @abstractmethod\n    def similarity(self, vector_a: IVector, vector_b: IVector) -> float:\n        \"\"\"\n        Compute the similarity between two vectors. The definition of similarity (e.g., cosine similarity)\n        should be implemented in concrete classes.\n\n        Args:\n            vector_a (IVector): The first vector.\n            vector_b (IVector): The second vector to compare with the first vector.\n\n        Returns:\n            float: A similarity score between vector_a and vector_b.\n        \"\"\"\n        pass\n\n\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorSpan.py",
        "content": "```swarmauri/core/vector_stores/IVectorSpan.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Any\n\nclass IVectorSpan(ABC):\n    \"\"\"\n    Interface for determining if a vector is within the span of a set of vectors.\n    \"\"\"\n\n    @abstractmethod\n    def in_span(self, vector: Any, basis_vectors: List[Any]) -> bool:\n        \"\"\"\n        Checks if the given vector is in the span of the provided basis vectors.\n\n        Parameters:\n        - vector (Any): The vector to check.\n        - basis_vectors (List[Any]): A list of vectors that might span the vector.\n\n        Returns:\n        - bool: True if the vector is in the span of the basis_vectors, False otherwise.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorArithmetic.py",
        "content": "```swarmauri/core/vector_stores/IVectorArithmetic.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass IVectorArithmetic(ABC):\n    @abstractmethod\n    def add(self, vector1: List[float], vector2: List[float]) -> List[float]:\n        \"\"\"\n        Vector addition of 'vector1' and 'vector2'.\n        \"\"\"\n        pass\n        \n    @abstractmethod\n    def subtract(self, vector1: List[float], vector2: List[float]) -> List[float]:\n        \"\"\"\n        Vector subtraction of 'vector1' - 'vector2'.\n        \"\"\"\n        pass\n   \n    @abstractmethod\n    def multiply(self, vector: List[float], scalar: float) -> List[float]:\n        \"\"\"\n        Scalar multiplication of 'vector' by 'scalar'.\n        \"\"\"\n        pass\n        \n    @abstractmethod\n    def divide(self, vector: List[float], scalar: float) -> List[float]:\n        \"\"\"\n        Scalar division of 'vector' by 'scalar'.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorLinearCombination.py",
        "content": "```swarmauri/core/vector_stores/IVectorLinearCombination.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Any\n\nclass ILinearCombination(ABC):\n    \"\"\"\n    Interface for creating a vector as a linear combination of a set of vectors.\n    \"\"\"\n\n    @abstractmethod\n    def linear_combination(self, coefficients: List[float], vectors: List[Any]) -> Any:\n        \"\"\"\n        Computes the linear combination of the given vectors with the specified coefficients.\n\n        Parameters:\n        - coefficients (List[float]): A list of coefficients for the linear combination.\n        - vectors (List[Any]): A list of vectors to be combined.\n\n        Returns:\n        - Any: The resulting vector from the linear combination.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorNorm.py",
        "content": "```swarmauri/core/vector_stores/IVectorNorm.py\n# core/vectors/IVectorNorm.py\n\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union\n\nclass IVectorNorm(ABC):\n    \"\"\"\n    Interface for calculating vector norms.\n    Supports L1 norm, L2 norm, and Max norm calculations.\n    \"\"\"\n\n    @abstractmethod\n    def l1_norm(self, vector: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the L1 norm (Manhattan norm) of a vector.\n\n        Parameters:\n        - vector (List[Union[int, float]]): The vector for which to calculate the L1 norm.\n\n        Returns:\n        - float: The L1 norm of the vector.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def l2_norm(self, vector: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the L2 norm (Euclidean norm) of a vector.\n\n        Parameters:\n        - vector (List[Union[int, float]]): The vector for which to calculate the L2 norm.\n\n        Returns:\n        - float: The L2 norm of the vector.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def max_norm(self, vector: List[Union[int, float]]) -> float:\n        \"\"\"\n        Calculate the Max norm (infinity norm) of a vector.\n\n        Parameters:\n        - vector (List[Union[int, float]]): The vector for which to calculate the Max norm.\n\n        Returns:\n        - float: The Max norm of the vector.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorRotate.py",
        "content": "```swarmauri/core/vector_stores/IVectorRotate.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass IRotate(ABC):\n    \"\"\"\n    Interface for rotating a vector.\n    \"\"\"\n    \n    @abstractmethod\n    def rotate(self, vector: List[float], angle: float, axis: List[float] = None) -> List[float]:\n        \"\"\"\n        Rotate the given vector by a specified angle around an axis (for 3D) or in a plane (for 2D).\n\n        For 2D vectors, the axis parameter can be omitted.\n\n        Args:\n            vector (List[float]): The vector to rotate.\n            angle (float): The angle of rotation in degrees.\n            axis (List[float], optional): The axis of rotation (applicable in 3D).\n\n        Returns:\n            List[float]: The rotated vector.\n        \"\"\"\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorBasisCheck.py",
        "content": "```swarmauri/core/vector_stores/IVectorBasisCheck.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Any\n\nclass IVectorBasisCheck(ABC):\n    \"\"\"\n    Interface for checking if a given set of vectors forms a basis of the vector space.\n    \"\"\"\n\n    @abstractmethod\n    def is_basis(self, vectors: List[Any]) -> bool:\n        \"\"\"\n        Determines whether the given set of vectors forms a basis for their vector space.\n\n        Parameters:\n        - vectors (List[Any]): A list of vectors to be checked.\n\n        Returns:\n        - bool: True if the vectors form a basis, False otherwise.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/__init__.py",
        "content": "```swarmauri/core/vector_stores/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorStore.py",
        "content": "```swarmauri/core/vector_stores/IVectorStore.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Union\nfrom swarmauri.core.vectors.IVector import IVector\nfrom swarmauri.core.documents.IDocument import IDocument\n\nclass IVectorStore(ABC):\n    \"\"\"\n    Interface for a vector store responsible for storing, indexing, and retrieving documents.\n    \"\"\"\n\n    @abstractmethod\n    def add_document(self, document: IDocument) -> None:\n        \"\"\"\n        Stores a single document in the vector store.\n\n        Parameters:\n        - document (IDocument): The document to store.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_documents(self, documents: List[IDocument]) -> None:\n        \"\"\"\n        Stores multiple documents in the vector store.\n\n        Parameters:\n        - documents (List[IDocument]): The list of documents to store.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_document(self, doc_id: str) -> Union[IDocument, None]:\n        \"\"\"\n        Retrieves a document by its ID.\n\n        Parameters:\n        - doc_id (str): The unique identifier for the document.\n\n        Returns:\n        - Union[IDocument, None]: The requested document, or None if not found.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_all_documents(self) -> List[IDocument]:\n        \"\"\"\n        Retrieves all documents stored in the vector store.\n\n        Returns:\n        - List[IDocument]: A list of all documents.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_document(self, doc_id: str) -> None:\n        \"\"\"\n        Deletes a document from the vector store by its ID.\n\n        Parameters:\n        - doc_id (str): The unique identifier of the document to delete.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def clear_documents(self) -> None:\n        \"\"\"\n        Deletes all documents from the vector store\n\n        \"\"\"\n        pass\n\n\n    @abstractmethod\n    def update_document(self, doc_id: str, updated_document: IDocument) -> None:\n        \"\"\"\n        Updates a document in the vector store.\n\n        Parameters:\n        - doc_id (str): The unique identifier for the document to update.\n        - updated_document (IDocument): The updated document object.\n\n        Note: It's assumed that the updated_document will retain the same doc_id but may have different content or metadata.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def document_count(self) -> int:\n        pass \n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorStoreRetrieve.py",
        "content": "```swarmauri/core/vector_stores/IVectorStoreRetrieve.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\nfrom swarmauri.core.documents.IDocument import IDocument\n\nclass IVectorStoreRetrieve(ABC):\n    \"\"\"\n    Abstract base class for document retrieval operations.\n    \n    This class defines the interface for retrieving documents based on a query or other criteria.\n    Implementations may use various indexing or search technologies to fulfill these retrievals.\n    \"\"\"\n\n    @abstractmethod\n    def retrieve(self, query: str, top_k: int = 5) -> List[IDocument]:\n        \"\"\"\n        Retrieve the most relevant documents based on the given query.\n        \n        Parameters:\n            query (str): The query string used for document retrieval.\n            top_k (int): The number of top relevant documents to retrieve.\n            \n        Returns:\n            List[Document]: A list of the top_k most relevant documents.\n        \"\"\"\n        pass\n\n\n```"
    },
    {
        "document_name": "swarmauri/core/vector_stores/IVectorStoreSaveLoad.py",
        "content": "```swarmauri/core/vector_stores/IVectorStoreSaveLoad.py\nfrom abc import ABC, abstractmethod\n\nclass IVectorStoreSaveLoad(ABC):\n    \"\"\"\n    Interface to abstract the ability to save and load the state of a vector store.\n    This includes saving/loading the vectorizer's model as well as the documents or vectors.\n    \"\"\"\n\n    @abstractmethod\n    def save_store(self, directory_path: str) -> None:\n        \"\"\"\n        Saves the state of the vector store to the specified directory. This includes\n        both the vectorizer's model and the stored documents or vectors.\n\n        Parameters:\n        - directory_path (str): The directory path where the store's state will be saved.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def load_store(self, directory_path: str) -> None:\n        \"\"\"\n        Loads the state of the vector store from the specified directory. This includes\n        both the vectorizer's model and the stored documents or vectors.\n\n        Parameters:\n        - directory_path (str): The directory path from where the store's state will be loaded.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def save_parts(self, directory_path: str, chunk_size: int=10485760) -> None:\n        \"\"\"\n        Save the model in parts to handle large files by splitting them.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def load_parts(self, directory_path: str, file_pattern: str) -> None:\n        \"\"\"\n        Load and combine model parts from a directory.\n\n        \"\"\"\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/document_stores/__init__.py",
        "content": "```swarmauri/core/document_stores/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/document_stores/IDocumentRetrieve.py",
        "content": "```swarmauri/core/document_stores/IDocumentRetrieve.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\nfrom swarmauri.core.documents.IDocument import IDocument\n\nclass IDocumentRetrieve(ABC):\n    \"\"\"\n    Abstract base class for document retrieval operations.\n    \n    This class defines the interface for retrieving documents based on a query or other criteria.\n    Implementations may use various indexing or search technologies to fulfill these retrievals.\n    \"\"\"\n\n    @abstractmethod\n    def retrieve(self, query: str, top_k: int = 5) -> List[IDocument]:\n        \"\"\"\n        Retrieve the most relevant documents based on the given query.\n        \n        Parameters:\n            query (str): The query string used for document retrieval.\n            top_k (int): The number of top relevant documents to retrieve.\n            \n        Returns:\n            List[Document]: A list of the top_k most relevant documents.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/document_stores/IDocumentStore.py",
        "content": "```swarmauri/core/document_stores/IDocumentStore.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union\nfrom swarmauri.core.documents.IDocument import IDocument\n\nclass IDocumentStore(ABC):\n    \"\"\"\n    Interface for a Document Store responsible for storing, indexing, and retrieving documents.\n    \"\"\"\n\n    @abstractmethod\n    def add_document(self, document: IDocument) -> None:\n        \"\"\"\n        Stores a single document in the document store.\n\n        Parameters:\n        - document (IDocument): The document to store.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_documents(self, documents: List[IDocument]) -> None:\n        \"\"\"\n        Stores multiple documents in the document store.\n\n        Parameters:\n        - documents (List[IDocument]): The list of documents to store.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_document(self, doc_id: str) -> Union[IDocument, None]:\n        \"\"\"\n        Retrieves a document by its ID.\n\n        Parameters:\n        - doc_id (str): The unique identifier for the document.\n\n        Returns:\n        - Union[IDocument, None]: The requested document, or None if not found.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_all_documents(self) -> List[IDocument]:\n        \"\"\"\n        Retrieves all documents stored in the document store.\n\n        Returns:\n        - List[IDocument]: A list of all documents.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_document(self, doc_id: str) -> None:\n        \"\"\"\n        Deletes a document from the document store by its ID.\n\n        Parameters:\n        - doc_id (str): The unique identifier of the document to delete.\n        \"\"\"\n        pass\n\n\n    @abstractmethod\n    def update_document(self, doc_id: str, updated_document: IDocument) -> None:\n        \"\"\"\n        Updates a document in the document store.\n\n        Parameters:\n        - doc_id (str): The unique identifier for the document to update.\n        - updated_document (IDocument): The updated document object.\n\n        Note: It's assumed that the updated_document will retain the same doc_id but may have different content or metadata.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def document_count(self) -> int:\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chunkers/IChunker.py",
        "content": "```swarmauri/core/chunkers/IChunker.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union, Any\n\nclass IChunker(ABC):\n    \"\"\"\n    Interface for chunking text into smaller pieces.\n\n    This interface defines abstract methods for chunking texts. Implementing classes\n    should provide concrete implementations for these methods tailored to their specific\n    chunking algorithms.\n    \"\"\"\n\n    @abstractmethod\n    def chunk_text(self, text: Union[str, Any], *args, **kwargs) -> List[Any]:\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chunkers/__init__.py",
        "content": "```swarmauri/core/chunkers/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/vectors/IVectorMeta.py",
        "content": "```swarmauri/core/vectors/IVectorMeta.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict, List\n\nclass IVectorMeta(ABC):\n    \"\"\"\n    Interface for a high-dimensional data vector. This interface defines the\n    basic structure and operations for interacting with vectors in various applications,\n    such as machine learning, information retrieval, and similarity search.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def id(self) -> str:\n        \"\"\"\n        Unique identifier for the vector. This ID can be used to reference the vector\n        in a database or a vector store.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def metadata(self) -> Dict[str, Any]:\n        \"\"\"\n        Optional metadata associated with the vector. Metadata can include additional information\n        useful for retrieval, categorization, or description of the vector data.\n        \"\"\"\n        pass\n\n\n```"
    },
    {
        "document_name": "swarmauri/core/vectors/IVectorTransform.py",
        "content": "```swarmauri/core/vectors/IVectorTransform.py\nfrom abc import ABC, abstractmethod\nfrom .IVector import IVector\n\nclass IVectorTransform(ABC):\n    \"\"\"\n    Interface for performing various transformations on vectors.\n    \"\"\"\n\n    @abstractmethod\n    def translate(self, translation_vector: IVector) -> IVector:\n        \"\"\"\n        Translate a vector by a given translation vector.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def rotate(self, angle: float, axis: IVector) -> IVector:\n        \"\"\"\n        Rotate a vector around a given axis by a certain angle.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def reflect(self, plane_normal: IVector) -> IVector:\n        \"\"\"\n        Reflect a vector across a plane defined by its normal vector.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def scale(self, scale_factor: float) -> IVector:\n        \"\"\"\n        Scale a vector by a given scale factor.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def shear(self, shear_factor: float, direction: IVector) -> IVector:\n        \"\"\"\n        Shear a vector along a given direction by a shear factor.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def project(self, plane_normal: IVector) -> IVector:\n        \"\"\"\n        Project a vector onto a plane defined by its normal vector.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vectors/__init__.py",
        "content": "```swarmauri/core/vectors/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/vectors/IVectorProduct.py",
        "content": "```swarmauri/core/vectors/IVectorProduct.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Tuple\n\nclass IVectorProduct(ABC):\n    \"\"\"\n    Interface for various vector products including dot product, cross product,\n    and triple products (vector and scalar).\n    \"\"\"\n\n    @abstractmethod\n    def dot_product(self, vector_a: List[float], vector_b: List[float]) -> float:\n        \"\"\"\n        Calculate the dot product of two vectors.\n\n        Parameters:\n        - vector_a (List[float]): The first vector.\n        - vector_b (List[float]): The second vector.\n\n        Returns:\n        - float: The dot product of the two vectors.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def cross_product(self, vector_a: List[float], vector_b: List[float]) -> List[float]:\n        \"\"\"\n        Calculate the cross product of two vectors.\n\n        Parameters:\n        - vector_a (List[float]): The first vector.\n        - vector_b (List[float]): The second vector.\n\n        Returns:\n        - List[float]: The cross product as a new vector.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def vector_triple_product(self, vector_a: List[float], vector_b: List[float], vector_c: List[float]) -> List[float]:\n        \"\"\"\n        Calculate the vector triple product of three vectors.\n\n        Parameters:\n        - vector_a (List[float]): The first vector.\n        - vector_b (List[float]): The second vector.\n        - vector_c (List[float]): The third vector.\n\n        Returns:\n        - List[float]: The result of the vector triple product as a new vector.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def scalar_triple_product(self, vector_a: List[float], vector_b: List[float], vector_c: List[float]) -> float:\n        \"\"\"\n        Calculate the scalar triple product of three vectors.\n\n        Parameters:\n        - vector_a (List[float]): The first vector.\n        - vector_b (List[float]): The second vector.\n        - vector_c (List[float]): The third vector.\n\n        Returns:\n        - float: The scalar value result of the scalar triple product.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/vectors/IVector.py",
        "content": "```swarmauri/core/vectors/IVector.py\nfrom abc import ABC, abstractmethod\n\nclass IVector(ABC):\n    \"\"\"\n    Interface for a high-dimensional data vector. This interface defines the\n    basic structure and operations for interacting with vectors in various applications,\n    such as machine learning, information retrieval, and similarity search.\n    \"\"\"\n\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/swarm_apis/__init__.py",
        "content": "```swarmauri/core/swarm_apis/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/swarm_apis/ISwarmAPI.py",
        "content": "```swarmauri/core/swarm_apis/ISwarmAPI.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any\n\nclass ISwarmAPI(ABC):\n    \"\"\"\n    Interface for managing the swarm's API endpoints.\n    \"\"\"\n    \n    @abstractmethod\n    def dispatch_request(self, request_data: Dict[str, Any]) -> Any:\n        \"\"\"\n        Dispatches an incoming user request to one or more suitable agents based on their capabilities.\n\n        Parameters:\n        - request_data (Dict[str, Any]): Data related to the incoming request.\n\n        Returns:\n        - Any: Response from processing the request.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def broadcast_request(self, request_data: Dict[str, Any]) -> Any:\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/swarm_apis/IAgentRegistrationAPI.py",
        "content": "```swarmauri/core/swarm_apis/IAgentRegistrationAPI.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Optional\nfrom swarmauri.core.agents.IAgent import IAgent\n\nclass IAgentRegistrationAPI(ABC):\n    \"\"\"\n    Interface for registering agents with the swarm, designed to support CRUD operations on IAgent instances.\n    \"\"\"\n\n    @abstractmethod\n    def register_agent(self, agent: IAgent) -> bool:\n        \"\"\"\n        Register a new agent with the swarm.\n\n        Parameters:\n            agent (IAgent): An instance of IAgent representing the agent to register.\n\n        Returns:\n            bool: True if the registration succeeded; False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_agent(self, agent_id: str, updated_agent: IAgent) -> bool:\n        \"\"\"\n        Update the details of an existing agent. This could include changing the agent's configuration,\n        task assignment, or any other mutable attribute.\n\n        Parameters:\n            agent_id (str): The unique identifier for the agent.\n            updated_agent (IAgent): An updated IAgent instance to replace the existing one.\n\n        Returns:\n            bool: True if the update was successful; False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_agent(self, agent_id: str) -> bool:\n        \"\"\"\n        Remove an agent from the swarm based on its unique identifier.\n\n        Parameters:\n            agent_id (str): The unique identifier for the agent to be removed.\n\n        Returns:\n            bool: True if the removal was successful; False otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_agent(self, agent_id: str) -> Optional[IAgent]:\n        \"\"\"\n        Retrieve an agent's instance from its unique identifier.\n\n        Parameters:\n            agent_id (str): The unique identifier for the agent of interest.\n\n        Returns:\n            Optional[IAgent]: The IAgent instance if found; None otherwise.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def list_agents(self) -> List[IAgent]:\n        \"\"\"\n        List all registered agents.\n\n        Returns:\n            List[IAgent]: A list containing instances of all registered IAgents.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/tracing/__init__.py",
        "content": "```swarmauri/core/tracing/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/tracing/ITraceContext.py",
        "content": "```swarmauri/core/tracing/ITraceContext.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any\n\nclass ITraceContext(ABC):\n    \"\"\"\n    Interface for a trace context, representing a single trace instance.\n    This context carries the state and metadata of the trace across different system components.\n    \"\"\"\n\n    @abstractmethod\n    def get_trace_id(self) -> str:\n        \"\"\"\n        Retrieves the unique identifier for this trace.\n\n        Returns:\n            str: The unique trace identifier.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_attribute(self, key: str, value: Any):\n        \"\"\"\n        Adds or updates an attribute associated with this trace.\n\n        Args:\n            key (str): The attribute key or name.\n            value (Any): The value of the attribute.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/tracing/ITracer.py",
        "content": "```swarmauri/core/tracing/ITracer.py\nfrom swarmauri.core.tracing.ITraceContext import ITraceContext\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Dict, Any\n\n\nclass ITracer(ABC):\n    \"\"\"\n    Interface for implementing distributed tracing across different components of the system.\n    \"\"\"\n\n    @abstractmethod\n    def start_trace(self, name: str, initial_attributes: Optional[Dict[str, Any]] = None) -> ITraceContext:\n        \"\"\"\n        Starts a new trace with a given name and optional initial attributes.\n\n        Args:\n            name (str): Name of the trace, usually represents the operation being traced.\n            initial_attributes (Optional[Dict[str, Any]]): Key-value pairs to be attached to the trace initially.\n\n        Returns:\n            ITraceContext: A context object representing this particular trace instance.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def end_trace(self, trace_context: ITraceContext):\n        \"\"\"\n        Marks the end of a trace, completing its lifecycle and recording its details.\n\n        Args:\n            trace_context (ITraceContext): The trace context to be ended.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def annotate_trace(self, trace_context: ITraceContext, key: str, value: Any):\n        \"\"\"\n        Adds an annotation to an existing trace, enriching it with more detailed information.\n\n        Args:\n            trace_context (ITraceContext): The trace context to annotate.\n            key (str): The key or name of the annotation.\n            value (Any): The value of the annotation.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/tracing/IChainTracer.py",
        "content": "```swarmauri/core/tracing/IChainTracer.py\nfrom abc import ABC, abstractmethod\nfrom typing import Callable, List, Tuple, Dict, Any\n\nclass IChainTracer(ABC):\n    \"\"\"\n    Interface for a tracer supporting method chaining through a list of tuples.\n    Each tuple in the list contains: trace context, function, args, and kwargs.\n    \"\"\"\n\n    @abstractmethod\n    def process_chain(self, chain: List[Tuple[Any, Callable[..., Any], List[Any], Dict[str, Any]]]) -> \"IChainTracer\":\n        \"\"\"\n        Processes a sequence of operations defined in a chain.\n\n        Args:\n            chain (List[Tuple[Any, Callable[..., Any], List[Any], Dict[str, Any]]]): A list where each tuple contains:\n                - The trace context or reference required by the function.\n                - The function (method of IChainTracer) to execute.\n                - A list of positional arguments for the function.\n                - A dictionary of keyword arguments for the function.\n\n        Returns:\n            IChainTracer: Returns self to allow further method chaining.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chains/ICallableChain.py",
        "content": "```swarmauri/core/chains/ICallableChain.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Callable, List, Tuple\n\nCallableDefinition = Tuple[Callable, List[Any], dict]\n\nclass ICallableChain(ABC):\n    @abstractmethod\n    def __call__(self, *initial_args: Any, **initial_kwargs: Any) -> Any:\n        \"\"\"Executes the chain of callables.\"\"\"\n        pass\n\n    @abstractmethod\n    def add_callable(self, func: Callable, args: List[Any] = None, kwargs: dict = None) -> None:\n        \"\"\"Adds a new callable to the chain.\"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chains/__init__.py",
        "content": "```swarmauri/core/chains/__init__.py\nfrom swarmauri.core.chains.ICallableChain import ICallableChain\n```"
    },
    {
        "document_name": "swarmauri/core/chains/IChain.py",
        "content": "```swarmauri/core/chains/IChain.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Any, Dict\nfrom swarmauri.core.chains.IChainStep import IChainStep\n\nclass IChain(ABC):\n    \"\"\"\n    Defines the interface for a Chain within a system, facilitating the organized\n    execution of a sequence of tasks or operations. This interface is at the core of\n    orchestrating operations that require coordination between multiple steps, potentially\n    involving decision-making, branching, and conditional execution based on the outcomes\n    of previous steps or external data.\n\n    A chain can be thought of as a workflow or pipeline, where each step in the chain can\n    perform an operation, transform data, or make decisions that influence the flow of\n    execution.\n\n    Implementors of this interface are responsible for managing the execution order,\n    data flow between steps, and any dynamic adjustments to the execution based on\n    runtime conditions.\n\n    Methods:\n        add_step: Adds a step to the chain.\n        remove_step: Removes a step from the chain.\n        execute: Executes the chain, potentially returning a result.\n    \"\"\"\n\n    @abstractmethod\n    def add_step(self, step: IChainStep, **kwargs) -> None:\n        \"\"\"\n        Adds a new step to the chain. Steps are executed in the order they are added.\n        Each step is represented by a Callable, which can be a function or method, with\n        optional keyword arguments that specify execution aspects or data needed by the step.\n\n        Parameters:\n            step (IChainStep): The Callable representing the step to add to the chain.\n            **kwargs: Optional keyword arguments that provide additional data or configuration\n                      for the step when it is executed.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_step(self, step: IChainStep) -> None:\n        \"\"\"\n        Removes an existing step from the chain. This alters the chain's execution sequence\n        by excluding the specified step from subsequent executions of the chain.\n\n        Parameters:\n            step (IChainStep): The Callable representing the step to remove from the chain.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def execute(self, *args, **kwargs) -> Any:\n        \"\"\"\n        Initiates the execution of the chain. This involves invoking each step in the order\n        they have been added to the chain, passing control from one step to the next, and optionally\n        aggregating or transforming results along the way.\n\n        The execution process can incorporate branching, looping, or conditional logic based on the\n        implementation, allowing for complex workflows to be represented and managed within the chain.\n\n        Parameters:\n            *args: Positional arguments passed to the first step in the chain. These can be data inputs\n                   or other values required for the chain's execution.\n            **kwargs: Keyword arguments that provide additional context, data inputs, or configuration\n                      for the chain's execution. These can be passed to individual steps or influence\n                      the execution flow of the chain.\n\n        Returns:\n            Any: The outcome of executing the chain. This could be a value produced by the final\n                 step, a collection of outputs from multiple steps, or any other result type as\n                 determined by the specific chain implementation.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chains/IChainContext.py",
        "content": "```swarmauri/core/chains/IChainContext.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any\n\nclass IChainContext(ABC):\n    \n    @abstractmethod\n    def update(self, **kwargs) -> None:\n        pass\n\n    def get_value(self, key: str) -> Any:\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chains/IChainContextLoader.py",
        "content": "```swarmauri/core/chains/IChainContextLoader.py\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any\n\nclass IChainContextLoader(ABC):\n    @abstractmethod\n    def load_context(self, context_id: str) -> Dict[str, Any]:\n        \"\"\"Load the execution context by its identifier.\"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chains/IChainDependencyResolver.py",
        "content": "```swarmauri/core/chains/IChainDependencyResolver.py\nfrom abc import ABC, abstractmethod\nfrom typing import Tuple, Dict, List, Optional\nfrom swarmauri.standard.chains.concrete.ChainStep import ChainStep\n\nclass IChainDependencyResolver(ABC):\n    @abstractmethod\n    def build_dependencies(self) -> List[ChainStep]:\n        \"\"\"\n        Builds the dependencies for a particular sequence in the matrix.\n\n        Args:\n            matrix (List[List[str]]): The prompt matrix.\n            sequence_index (int): The index of the sequence to build dependencies for.\n\n        Returns:\n            Tuple containing indegrees and graph dicts.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def resolve_dependencies(self, matrix: List[List[Optional[str]]], sequence_index: int) -> List[int]:\n        \"\"\"\n        Resolves the execution order based on the provided dependencies.\n\n        Args:\n            indegrees (Dict[int, int]): The indegrees of each node.\n            graph (Dict[int, List[int]]): The graph representing dependencies.\n\n        Returns:\n            List[int]: The resolved execution order.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/chains/IChainFactory.py",
        "content": "```swarmauri/core/chains/IChainFactory.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Any, Dict\nfrom swarmauri.core.chains.IChain import IChain\nfrom swarmauri.core.chains.IChainStep import IChainStep\n\nclass IChainFactory(ABC):\n    \"\"\"\n    Interface for creating and managing execution chains within the system.\n    \"\"\"\n\n    @abstractmethod\n    def create_chain(self, steps: List[IChainStep] = None) -> IChain:\n        pass\n    \n    \n    @abstractmethod\n    def get_chain(self) -> IChain:\n        pass\n    \n    @abstractmethod\n    def set_chain(self, chain: IChain):\n        pass\n    \n    @abstractmethod\n    def reset_chain(self):\n        pass\n    \n    @abstractmethod\n    def get_chain_steps(self) -> List[IChainStep]:\n        pass\n    \n    @abstractmethod\n    def set_chain_steps(self, steps: List[IChainStep]):\n        pass\n    \n    @abstractmethod\n    def add_chain_step(self, step: IChainStep):\n        pass\n    \n    @abstractmethod\n    def remove_chain_step(self, key: str):\n        pass\n    \n    @abstractmethod\n    def get_configs(self) -> Dict[str, Any]:\n        pass\n    \n    @abstractmethod\n    def set_configs(self, **configs):\n        pass\n    \n    @abstractmethod\n    \n    def get_config(self, key: str) -> Any:\n        pass\n    \n    @abstractmethod\n    def set_config(self, key: str, value: Any):\n        pass\n    \n\n\n```"
    },
    {
        "document_name": "swarmauri/core/chains/IChainStep.py",
        "content": "```swarmauri/core/chains/IChainStep.py\nfrom typing import List, Dict, Any, Callable\n\nclass IChainStep:\n    \"\"\"\n    Represents a single step within an execution chain.\n    \"\"\"\n    pass\n```"
    },
    {
        "document_name": "swarmauri/core/distances/__init__.py",
        "content": "```swarmauri/core/distances/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/distances/IDistanceSimilarity.py",
        "content": "```swarmauri/core/distances/IDistanceSimilarity.py\nfrom abc import ABC, abstractmethod\nfrom typing import List\nfrom swarmauri.core.vectors.IVector import IVector\n\nclass IDistanceSimilarity(ABC):\n    \"\"\"\n    Interface for computing distances and similarities between high-dimensional data vectors. This interface\n    abstracts the method for calculating the distance and similarity, allowing for the implementation of various \n    distance metrics such as Euclidean, Manhattan, Cosine similarity, etc.\n    \"\"\"\n\n    @abstractmethod\n    def distance(self, vector_a: IVector, vector_b: IVector) -> float:\n        \"\"\"\n        Computes the distance between two vectors.\n\n        Args:\n            vector_a (IVector): The first vector in the comparison.\n            vector_b (IVector): The second vector in the comparison.\n\n        Returns:\n            float: The computed distance between vector_a and vector_b.\n        \"\"\"\n        pass\n    \n\n    @abstractmethod\n    def distances(self, vector_a: IVector, vectors_b: List[IVector]) -> float:\n        pass\n\n\n    @abstractmethod\n    def similarity(self, vector_a: IVector, vector_b: IVector) -> float:\n        \"\"\"\n        Compute the similarity between two vectors. The definition of similarity (e.g., cosine similarity)\n        should be implemented in concrete classes.\n\n        Args:\n            vector_a (IVector): The first vector.\n            vector_b (IVector): The second vector to compare with the first vector.\n\n        Returns:\n            float: A similarity score between vector_a and vector_b.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def similarities(self, vector_a: IVector, vectors_b: List[IVector]) -> float:\n        pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/metrics/__init__.py",
        "content": "```swarmauri/core/metrics/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/metrics/IMetric.py",
        "content": "```swarmauri/core/metrics/IMetric.py\nfrom typing import Any\nfrom abc import ABC, abstractmethod\n\nclass IMetric(ABC):\n    \"\"\"\n    Defines a general interface for metrics within the SwarmaURI system.\n    Metrics can be anything from system performance measurements to\n    machine learning model evaluation metrics.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self, **kwargs) -> Any:\n        \"\"\"\n        Retrieves the current value of the metric.\n\n        Returns:\n            The current value of the metric.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/metrics/IMetricAggregate.py",
        "content": "```swarmauri/core/metrics/IMetricAggregate.py\nfrom typing import List, Any\nfrom abc import ABC, abstractmethod\n\nclass IMetricAggregate(ABC):\n\n    @abstractmethod\n    def add_measurement(self, measurement: Any) -> None:\n        pass\n\n    @abstractmethod\n    def reset(self) -> None:\n        \"\"\"\n        Reset or clear the metric's current state, starting fresh as if no data had been processed.\n        This is useful for metrics that might aggregate or average data over time and need to be reset.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/metrics/IMetricCalculate.py",
        "content": "```swarmauri/core/metrics/IMetricCalculate.py\nfrom typing import Any\nfrom abc import ABC, abstractmethod\n\nclass IMetricCalculate(ABC):\n\n    @abstractmethod\n    def calculate(self, **kwargs) -> Any:\n        \"\"\"\n        Calculate the metric based on the provided data.\n\n        Args:\n            *args: Variable length argument list that the metric calculation might require.\n            **kwargs: Arbitrary keyword arguments that the metric calculation might require.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update(self, value) -> None:\n        \"\"\"\n        Update the metric value based on new information.\n\n        Args:\n            value: The new information used to update the metric. This could be a new\n            measurement or data point that affects the metric's current value.\n\n        Note:\n            This method is intended for internal use and should not be publicly accessible.\n        \"\"\"\n        pass\n        \n```"
    },
    {
        "document_name": "swarmauri/core/metrics/IThreshold.py",
        "content": "```swarmauri/core/metrics/IThreshold.py\nfrom abc import ABC, abstractmethod\n\nclass IThreshold(ABC):\n    pass\n\n```"
    },
    {
        "document_name": "swarmauri/core/experiment_stores/__init__.py",
        "content": "```swarmauri/core/experiment_stores/__init__.py\n# core/experiment_stores/IExperimentStore.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any, Union\nfrom swarmauri.core.documents.IExperimentDocument import IExperimentDocument\n\nclass IExperimentStore(ABC):\n    \"\"\"\n    Interface for an Experiment Store that manages experimental documents and supports\n    operations related to experimenting, evaluating, testing, and benchmarking.\n    \"\"\"\n    @abstractmethod\n    def add_experiment(self, experiment: IExperimentDocument) -> None:\n        \"\"\"\n        Stores a single experiment in the experiment store.\n\n        Parameters:\n        - experiment (IExperimentDocument): The experimental document to be stored.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_experiments(self, experiments: List[IExperimentDocument]) -> None:\n        \"\"\"\n        Stores multiple experiments in the experiment store.\n\n        Parameters:\n        - experiments (List[IExperimentDocument]): The list of experimental documents to be stored.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_experiment(self, experiment_id: str) -> Union[IExperimentDocument, None]:\n        \"\"\"\n        Retrieves an experimental document by its ID.\n\n        Parameters:\n        - id (str): The unique identifier of the experiment.\n\n        Returns:\n        - Union[IExperimentDocument, None]: The requested experimental document, or None if not found.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_all_experiments(self) -> List[IExperimentDocument]:\n        \"\"\"\n        Retrieves all experimental documents stored in the experiment store.\n\n        Returns:\n        - List[IExperimentDocument]: A list of all experimental documents.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_experiment(self, experiment_id: str, updated_experiment: IExperimentDocument) -> None:\n        \"\"\"\n        Updates an experimental document in the experiment store.\n\n        Parameters:\n        - id (str): The unique identifier of the experiment to update.\n        - updated_experiment (IExperimentDocument): The updated experimental document.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_experiment(self, experiment_id: str) -> None:\n        \"\"\"\n        Deletes an experimental document from the experiment store by its ID.\n\n        Parameters:\n        - id (str): The unique identifier of the experimental document to be deleted.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def evaluate_experiments(self, evaluation_criteria: Dict[str, Any]) -> Any:\n        \"\"\"\n        Evaluates the experiments stored in the experiment store based on given criteria and metrics.\n\n        Parameters:\n        - evaluation_criteria (Dict[str, Any]): The criteria and metrics to evaluate the experiments.\n\n        Returns:\n        - Any: The evaluation results, which may vary depending on the evaluation criteria.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def benchmark_experiments(self, benchmarking_data: Dict[str, Any]) -> Any:\n        \"\"\"\n        Benchmarks the experiments against each other or predefined standards.\n\n        Parameters:\n        - benchmarking_data (Dict[str, Any]): Data and parameters for benchmarking the experiments.\n\n        Returns:\n        - Any: The benchmark results, which may vary depending on the benchmarking methodology.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/experiment_stores/IExperimentStore.py",
        "content": "```swarmauri/core/experiment_stores/IExperimentStore.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any, Union\nfrom swarmauri.core.documents.IExperimentDocument import IExperimentDocument\n\nclass IExperimentStore(ABC):\n    \"\"\"\n    Interface for an Experiment Store that manages experimental documents and supports\n    operations related to experimenting, evaluating, testing, and benchmarking.\n    \"\"\"\n    @abstractmethod\n    def add_experiment(self, experiment: IExperimentDocument) -> None:\n        \"\"\"\n        Stores a single experiment in the experiment store.\n\n        Parameters:\n        - experiment (IExperimentDocument): The experimental document to be stored.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_experiments(self, experiments: List[IExperimentDocument]) -> None:\n        \"\"\"\n        Stores multiple experiments in the experiment store.\n\n        Parameters:\n        - experiments (List[IExperimentDocument]): The list of experimental documents to be stored.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_experiment(self, experiment_id: str) -> Union[IExperimentDocument, None]:\n        \"\"\"\n        Retrieves an experimental document by its ID.\n\n        Parameters:\n        - experiment_id (str): The unique identifier of the experiment.\n\n        Returns:\n        - Union[IExperimentDocument, None]: The requested experimental document, or None if not found.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_all_experiments(self) -> List[IExperimentDocument]:\n        \"\"\"\n        Retrieves all experimental documents stored in the experiment store.\n\n        Returns:\n        - List[IExperimentDocument]: A list of all experimental documents.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_experiment(self, experiment_id: str, updated_experiment: IExperimentDocument) -> None:\n        \"\"\"\n        Updates an experimental document in the experiment store.\n\n        Parameters:\n        - experiment_id (str): The unique identifier of the experiment to update.\n        - updated_experiment (IExperimentDocument): The updated experimental document.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete_experiment(self, experiment_id: str) -> None:\n        \"\"\"\n        Deletes an experimental document from the experiment store by its ID.\n\n        Parameters:\n        - experiment_id (str): The unique identifier of the experimental document to be deleted.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/agent_factories/IAgentFactory.py",
        "content": "```swarmauri/core/agent_factories/IAgentFactory.py\nfrom abc import ABC, abstractmethod\nfrom typing import Type, Any\nfrom datetime import datetime\n\nclass IAgentFactory(ABC):\n    \"\"\"\n    Interface for Agent Factories, extended to include properties like ID, name, type,\n    creation date, and last modification date.\n    \"\"\"\n\n    @abstractmethod\n    def create_agent(self, agent_type: str, **kwargs) -> Any:\n        pass\n\n    @abstractmethod\n    def register_agent(self, agent_type: str, constructor: Type[Any]) -> None:\n        pass\n\n    # Abstract properties and setters\n    @property\n    @abstractmethod\n    def id(self) -> str:\n        \"\"\"Unique identifier for the factory instance.\"\"\"\n        pass\n\n    @id.setter\n    @abstractmethod\n    def id(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"Name of the factory.\"\"\"\n        pass\n\n    @name.setter\n    @abstractmethod\n    def name(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def type(self) -> str:\n        \"\"\"Type of agents this factory produces.\"\"\"\n        pass\n\n    @type.setter\n    @abstractmethod\n    def type(self, value: str) -> None:\n        pass\n\n    @property\n    @abstractmethod\n    def date_created(self) -> datetime:\n        \"\"\"The creation date of the factory instance.\"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def last_modified(self) -> datetime:\n        \"\"\"Date when the factory was last modified.\"\"\"\n        pass\n\n    @last_modified.setter\n    @abstractmethod\n    def last_modified(self, value: datetime) -> None:\n        pass\n\n    def __hash__(self):\n        \"\"\"\n        The __hash__ method allows objects of this class to be used in sets and as dictionary keys.\n        __hash__ should return an integer and be defined based on immutable properties.\n        This is generally implemented directly in concrete classes rather than in the interface,\n        but it's declared here to indicate that implementing classes must provide it.\n        \"\"\"\n        pass\n\n   \n```"
    },
    {
        "document_name": "swarmauri/core/agent_factories/__init__.py",
        "content": "```swarmauri/core/agent_factories/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/core/agent_factories/IExportConf.py",
        "content": "```swarmauri/core/agent_factories/IExportConf.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict\n\nclass IExportConf(ABC):\n    \"\"\"\n    Interface for exporting configurations related to agent factories.\n    \n    Implementing classes are expected to provide functionality for representing\n    the factory's configuration as a dictionary, JSON string, or exporting to a file.\n    \"\"\"\n\n    @abstractmethod\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the agent factory's configuration to a dictionary.\n        \n        Returns:\n            Dict[str, Any]: A dictionary representation of the factory's configuration.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_json(self) -> str:\n        \"\"\"\n        Serializes the agent factory's configuration to a JSON string.\n        \n        Returns:\n            str: A JSON string representation of the factory's configuration.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_file(self, file_path: str) -> None:\n        \"\"\"\n        Exports the agent factory's configuration to a file in a suitable format.\n        \n        Parameters:\n            file_path (str): The path to the file where the configuration should be saved.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/embeddings/IFeature.py",
        "content": "```swarmauri/core/embeddings/IFeature.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Any\n\nclass IFeature(ABC):\n\n    @abstractmethod\n    def extract_features(self) -> List[Any]:\n        pass\n    \n\n```"
    },
    {
        "document_name": "swarmauri/core/embeddings/ISaveModel.py",
        "content": "```swarmauri/core/embeddings/ISaveModel.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any\n\nclass ISaveModel(ABC):\n    \"\"\"\n    Interface to abstract the ability to save and load models.\n    \"\"\"\n\n    @abstractmethod\n    def save_model(self, path: str) -> None:\n        \"\"\"\n        Saves the model to the specified directory.\n\n        Parameters:\n        - path (str): The directory path where the model will be saved.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def load_model(self, path: str) -> Any:\n        \"\"\"\n        Loads a model from the specified directory.\n\n        Parameters:\n        - path (str): The directory path from where the model will be loaded.\n\n        Returns:\n        - Returns an instance of the loaded model.\n        \"\"\"\n        pass\n```"
    },
    {
        "document_name": "swarmauri/core/embeddings/IVectorize.py",
        "content": "```swarmauri/core/embeddings/IVectorize.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union, Any\nfrom swarmauri.core.vectors.IVector import IVector\n\nclass IVectorize(ABC):\n    \"\"\"\n    Interface for converting text to vectors. \n    Implementations of this interface transform input text into numerical \n    vectors that can be used in machine learning models, similarity calculations, \n    and other vector-based operations.\n    \"\"\"\n    @abstractmethod\n    def fit(self, data: Union[str, Any]) -> None:\n        pass\n    \n    @abstractmethod\n    def transform(self, data: Union[str, Any]) -> List[IVector]:\n        pass\n\n    @abstractmethod\n    def fit_transform(self, data: Union[str, Any]) -> List[IVector]:\n        pass\n\n    @abstractmethod\n    def infer_vector(self, data: Union[str, Any], *args, **kwargs) -> IVector:\n        pass \n```"
    },
    {
        "document_name": "swarmauri/core/embeddings/__init__.py",
        "content": "```swarmauri/core/embeddings/__init__.py\n#\n```"
    },
    {
        "document_name": "swarmauri/core/schema_converters/ISchemaConvert.py",
        "content": "```swarmauri/core/schema_converters/ISchemaConvert.py\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict\nfrom swarmauri.core.tools.ITool import ITool\n\nclass ISchemaConvert(ABC):\n\n    @abstractmethod\n    def convert(self, tool: ITool) -> Dict[str, Any]:\n        raise NotImplementedError(\"Subclasses must implement the convert method.\")\n\n```"
    },
    {
        "document_name": "swarmauri/core/schema_converters/__init__.py",
        "content": "```swarmauri/core/schema_converters/__init__.py\n\n```"
    }
]